# Story 2.1: TDS API Integration for Server-Side Decisions

## Status
Draft

## Story
**As a** system administrator,
**I want** the application to communicate with our cloaking service API,
**so that** we can make intelligent decisions about content visibility.

## Acceptance Criteria
1. Create TDS API client with TypeScript interfaces for requests/responses
2. Implement server-side API call in page.tsx with click ID extraction
3. Pass user-agent, IP (via headers), and timestamp to TDS API
4. Handle TDS API response containing initial mode and verification token
5. Implement proper error handling with white mode as fallback
6. Add configurable API timeout (default 50ms) with environment variable
7. Create mock TDS responses for local development
8. Log all TDS decisions for debugging (without sensitive data)

## Tasks / Subtasks
- [ ] Create TDS API types and schemas (AC: 1, 4)
  - [ ] Create src/lib/services/tracker/tracker.types.ts
  - [ ] Define CloakDecisionRequest interface with userAgent, ip, clickId, articleSlug, timestamp
  - [ ] Define CloakDecisionResponse with mode, verifyToken, reason, ttl
  - [ ] Create Zod schemas for response validation
  - [ ] Export TypeScript types from Zod schemas
- [ ] Build TDS API client service (AC: 1, 5, 6)
  - [ ] Create src/lib/services/tracker/tracker.api.ts with 'server-only' import
  - [ ] Implement decideCloakMode() method with proper typing
  - [ ] Configure timeout to 50ms (override base client default)
  - [ ] Add environment variable TDS_API_TIMEOUT for timeout configuration
  - [ ] Handle API errors and always return white mode on failure
  - [ ] Use React.cache() wrapper for request deduplication
- [ ] Extract click tracking parameters (AC: 2, 3)
  - [ ] Update src/app/(marketing)/article/[slug]/page.tsx
  - [ ] Extract yclid and gclid from searchParams
  - [ ] Get user-agent from headers().get('user-agent')
  - [ ] Get IP from headers().get('x-forwarded-for') or 'x-real-ip'
  - [ ] Generate ISO timestamp for request
- [ ] Integrate TDS API in article page (AC: 2, 3, 4)
  - [ ] Call TDS API service in the Server Component
  - [ ] Pass extracted parameters to decideCloakMode()
  - [ ] Store decision result (mode and verifyToken) for client use
  - [ ] Pass cloaking decision to client components via props
  - [ ] Ensure no caching of pages with cloaking decisions
- [ ] Implement structured logging (AC: 8)
  - [ ] Create src/lib/logging/logger.ts with pino setup
  - [ ] Add cloakLogger instance for cloaking events
  - [ ] Log cloak_decision events with mode, reason, clickId (redacted), articleSlug
  - [ ] Include trace ID for request correlation
  - [ ] Never log sensitive data (IPs, full user agents)
  - [ ] Add timing metrics for API call duration
- [ ] Create mock TDS API for development (AC: 7)
  - [ ] Create src/app/api/mock-tds/decide/route.ts
  - [ ] Implement logic to simulate various TDS responses
  - [ ] Return black mode for yclid/gclid within 5 minutes
  - [ ] Return white mode for no click ID or expired
  - [ ] Simulate random verification tokens
  - [ ] Add artificial delay to test timeout handling
  - [ ] Include environment flag to enable/disable mock
- [ ] Update environment configuration (AC: 6)
  - [ ] Add TDS_API_URL to .env.example
  - [ ] Add TDS_API_KEY for authentication
  - [ ] Add TDS_API_TIMEOUT with default 50
  - [ ] Add USE_MOCK_TDS flag for development
  - [ ] Document all TDS-related environment variables
- [ ] Add error handling and monitoring (AC: 5, 8)
  - [ ] Create custom TrackerAPIError class
  - [ ] Implement retry logic for transient failures
  - [ ] Add performance monitoring for API latency
  - [ ] Set up alerts for high error rates
  - [ ] Test timeout scenarios thoroughly
- [ ] Write integration tests (AC: 1-8)
  - [ ] Test successful cloaking decisions
  - [ ] Test timeout handling (50ms limit)
  - [ ] Test fallback to white mode on errors
  - [ ] Test click ID extraction logic
  - [ ] Verify logging output format

## Dev Notes
### Previous Story Insights
- Epic 1 established the foundation: Next.js app with routing, API integration, and article rendering
- Article pages are Server Components that can make server-side API calls
- HTTP client with timeout support already exists from Story 1.3

### TDS API Integration Pattern
Based on [Source: architecture/api-integration.md#server-only-service-layer-pattern]:
- Must use 'server-only' import to prevent client exposure
- Service location: /lib/services/tracker/tracker.api.ts
- Use base HTTP client from /lib/http/client.ts
- Never cache cloaking decisions: `cache: 'no-store'`

### Cloaking Decision Logic
Based on [Source: architecture/cloak.md#two-stage-approach]:
- Two-stage: Server decision → Client verification
- 5-minute window from first click ID visit
- Decision rules:
  - No click ID → WHITE mode
  - Valid click ID within 5 mins → Provisional BLACK
  - Expired or suspicious → WHITE mode
- Always fail to WHITE mode on errors

### API Response Schema
Based on [Source: architecture/two-stage-cloaking-integration.md]:
```typescript
CloakDecisionResponse: {
  mode: 'white' | 'black'
  verifyToken?: string  // UUID for black mode
  reason?: string       // Decision explanation
  timestamp?: string    // ISO datetime
  ttl?: number         // Time to live
}
```

### Click ID Handling
Based on [Source: architecture/routing.md]:
- Extract yclid (Yandex) and gclid (Google) parameters
- Parameters preserved via middleware cookies (5-minute duration)
- Single-use protection per fingerprint

### Logging Strategy
Based on [Source: architecture/observability-strategy.md#structured-logging]:
- Use pino for structured server-side logging
- Create cloakLogger for cloaking-specific events
- Event types: cloak_decision, cloak_verification, cloak_violation
- Include trace ID for request correlation
- Redact sensitive data (IPs, user agents)

### Error Handling
Based on [Source: architecture/development-standards.md#error-handling-standards]:
- Custom error classes with proper context
- Always fail gracefully to WHITE mode
- Log errors with structured format
- Include timing metrics

### File Locations
Based on [Source: architecture/source-tree.md]:
```
src/
├── lib/
│   ├── services/
│   │   └── tracker/
│   │       ├── tracker.api.ts
│   │       └── tracker.types.ts
│   └── logging/
│       └── logger.ts
├── app/
│   ├── (marketing)/
│   │   └── article/
│   │       └── [slug]/
│   │           └── page.tsx (update)
│   └── api/
│       └── mock-tds/
│           └── decide/
│               └── route.ts
└── types/
    └── cloak.ts
```

### Testing
Based on [Source: architecture/testing-strategy.md]:
- Use MSW to mock TDS API responses
- Test various timeout scenarios
- Verify fallback behavior
- Check logging output

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-07 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_