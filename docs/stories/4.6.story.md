# Story 4.6: Custom Event Architecture

## Status
Draft

## Story
**As a** data analyst,
**I want** consistent event tracking across all platforms,
**so that** we can build unified dashboards.

## Acceptance Criteria
1. Define standard event naming convention
2. Create TypeScript types for all custom events
3. Implement event abstraction layer for all analytics
4. Document event schema with required properties
5. Create debug mode for event validation
6. Set up real-time event monitoring dashboard
7. Implement event batching for performance
8. Test events fire correctly across all analytics platforms

## Tasks / Subtasks
- [ ] Define event naming convention and registry (AC: 1, 2)
  - [ ] Create event naming standards document
  - [ ] Define event categories and actions
  - [ ] Create TypeScript enums for event names
  - [ ] Build event registry with metadata
  - [ ] Document naming patterns
  - [ ] Create migration guide for existing events
- [ ] Create TypeScript event schemas (AC: 2, 4)
  - [ ] Define base event interface
  - [ ] Create specific event type definitions
  - [ ] Add Zod schemas for runtime validation
  - [ ] Generate TypeScript types from schemas
  - [ ] Document required vs optional properties
  - [ ] Test type inference works correctly
- [ ] Build unified event abstraction layer (AC: 3)
  - [ ] Create EventManager singleton class
  - [ ] Implement platform adapter pattern
  - [ ] Add automatic property enrichment
  - [ ] Build event transformation pipeline
  - [ ] Create platform-specific adapters
  - [ ] Test cross-platform consistency
- [ ] Implement event validation system (AC: 5)
  - [ ] Create validation middleware
  - [ ] Add schema validation for all events
  - [ ] Implement debug mode with console output
  - [ ] Create validation error reporting
  - [ ] Add development-only strict mode
  - [ ] Test validation catches malformed events
- [ ] Create event monitoring dashboard (AC: 6)
  - [ ] Build debug dashboard component
  - [ ] Implement event stream visualization
  - [ ] Add platform status indicators
  - [ ] Create event inspector with details
  - [ ] Add filtering and search capabilities
  - [ ] Test dashboard in development mode
- [ ] Implement event batching system (AC: 7)
  - [ ] Create event queue with size limits
  - [ ] Implement time-based flushing
  - [ ] Add immediate flush for critical events
  - [ ] Build retry mechanism for failures
  - [ ] Optimize for performance
  - [ ] Test batching reduces network calls
- [ ] Update all analytics integrations (AC: 3, 8)
  - [ ] Refactor GTM integration to use new system
  - [ ] Update GA4 adapter for unified events
  - [ ] Migrate Yandex Metrica to new pattern
  - [ ] Update PostHog event tracking
  - [ ] Ensure Sentry context uses unified data
  - [ ] Test all platforms receive correct data
- [ ] Create comprehensive documentation (AC: 4)
  - [ ] Document all event types and properties
  - [ ] Create event flow diagrams
  - [ ] Write integration guide
  - [ ] Add troubleshooting section
  - [ ] Generate auto-documentation from types
  - [ ] Create examples for common scenarios
- [ ] Build testing utilities (AC: 8)
  - [ ] Create event testing helpers
  - [ ] Add mock event generators
  - [ ] Build assertion utilities
  - [ ] Create platform simulators
  - [ ] Add E2E event verification
  - [ ] Test event flow end-to-end
- [ ] Write migration scripts (AC: 1-8)
  - [ ] Create backward compatibility layer
  - [ ] Build migration utilities
  - [ ] Update existing event calls
  - [ ] Test migrations don't break tracking
  - [ ] Document migration process
  - [ ] Create rollback plan

## Dev Notes
### Previous Story Insights
- Story 4.1: GTM uses dataLayer with custom event structure
- Story 4.2: GA4 has Enhanced Ecommerce events with specific formats
- Story 4.3: Yandex uses goal IDs and specific parameter names
- Story 4.4: PostHog has its own event conventions with $ prefixes
- Story 4.5: Sentry needs error context enrichment
- All platforms need trace_id for correlation
- Cloak mode affects what events should be sent

### Event Naming Convention
Based on industry standards and existing patterns:
```typescript
// src/lib/analytics/events/naming.ts
export const EVENT_NAMING = {
  // Category_Action format with snake_case
  PAGE_VIEW: 'page_view',
  CLOAK_DECISION: 'cloak_decision',
  PROMOCODE_VIEWED: 'promocode_viewed',
  PROMOCODE_COPIED: 'promocode_copied', 
  PROMOCODE_CLICKED: 'promocode_clicked',
  SCROLL_MILESTONE: 'scroll_milestone',
  ERROR_OCCURRED: 'error_occurred',
  PERFORMANCE_METRIC: 'performance_metric',
} as const

export type EventName = typeof EVENT_NAMING[keyof typeof EVENT_NAMING]

// Event categories for grouping
export enum EventCategory {
  NAVIGATION = 'navigation',
  ENGAGEMENT = 'engagement',
  CONVERSION = 'conversion',
  TECHNICAL = 'technical',
  PERFORMANCE = 'performance',
}
```

### TypeScript Event Schemas
Based on [Source: architecture/type-safety-validation.md]:
```typescript
// src/lib/analytics/events/schemas.ts
import { z } from 'zod'

// Base event schema - all events must have these
export const BaseEventSchema = z.object({
  eventName: z.string(),
  timestamp: z.string().datetime(),
  traceId: z.string(),
  sessionId: z.string(),
  properties: z.record(z.unknown()),
  context: z.object({
    page: z.object({
      path: z.string(),
      title: z.string(),
      referrer: z.string().optional(),
    }),
    user: z.object({
      id: z.string(),
      isAnonymous: z.boolean(),
      source: z.enum(['direct', 'google', 'yandex', 'facebook', 'other']),
    }),
    device: z.object({
      type: z.enum(['desktop', 'mobile', 'tablet']),
      viewport: z.object({
        width: z.number(),
        height: z.number(),
      }),
    }),
    session: z.object({
      cloakMode: z.enum(['white', 'black']).optional(),
      featureFlags: z.record(z.string(), z.unknown()).optional(),
    }),
  }),
})

// Specific event schemas
export const PageViewEventSchema = BaseEventSchema.extend({
  eventName: z.literal(EVENT_NAMING.PAGE_VIEW),
  properties: z.object({
    articleSlug: z.string().optional(),
    isFirstView: z.boolean(),
  }),
})

export const PromocodeEventSchema = BaseEventSchema.extend({
  eventName: z.enum([
    EVENT_NAMING.PROMOCODE_VIEWED,
    EVENT_NAMING.PROMOCODE_COPIED,
    EVENT_NAMING.PROMOCODE_CLICKED,
  ]),
  properties: z.object({
    code: z.string(),
    merchant: z.string(),
    discount: z.string(),
    position: z.string(),
    widgetType: z.enum(['inline', 'modal', 'sticky']),
    targetUrl: z.string().url().optional(),
  }),
})

// Generate TypeScript types from schemas
export type BaseEvent = z.infer<typeof BaseEventSchema>
export type PageViewEvent = z.infer<typeof PageViewEventSchema>
export type PromocodeEvent = z.infer<typeof PromocodeEventSchema>

// Union type of all events
export type AnalyticsEvent = PageViewEvent | PromocodeEvent // | other events...
```

### Unified Event Manager
Based on existing analytics patterns:
```typescript
// src/lib/analytics/events/event-manager.ts
import { BaseEvent, AnalyticsEvent } from './schemas'
import { GTMAdapter } from './adapters/gtm'
import { GA4Adapter } from './adapters/ga4'
import { YandexAdapter } from './adapters/yandex'
import { PostHogAdapter } from './adapters/posthog'
import { EventQueue } from './queue'

export class EventManager {
  private static instance: EventManager
  private adapters: Map<string, AnalyticsAdapter>
  private queue: EventQueue
  private debugMode: boolean = false
  
  private constructor() {
    this.adapters = new Map([
      ['gtm', new GTMAdapter()],
      ['ga4', new GA4Adapter()],
      ['yandex', new YandexAdapter()],
      ['posthog', new PostHogAdapter()],
    ])
    
    this.queue = new EventQueue({
      maxSize: 100,
      flushInterval: 5000, // 5 seconds
      onFlush: (events) => this.sendBatch(events),
    })
  }
  
  static getInstance(): EventManager {
    if (!EventManager.instance) {
      EventManager.instance = new EventManager()
    }
    return EventManager.instance
  }
  
  track(eventName: EventName, properties: Record<string, any> = {}) {
    const event = this.createEvent(eventName, properties)
    
    // Validate event
    if (this.debugMode) {
      this.validateEvent(event)
    }
    
    // Check if event should be tracked based on cloak mode
    if (!this.shouldTrackEvent(event)) {
      return
    }
    
    // Add to queue or send immediately
    if (this.isCriticalEvent(eventName)) {
      this.sendImmediate(event)
    } else {
      this.queue.add(event)
    }
  }
  
  private createEvent(eventName: EventName, properties: Record<string, any>): AnalyticsEvent {
    const baseEvent: BaseEvent = {
      eventName,
      timestamp: new Date().toISOString(),
      traceId: window.__TRACE_ID__ || 'unknown',
      sessionId: this.getSessionId(),
      properties,
      context: {
        page: {
          path: window.location.pathname,
          title: document.title,
          referrer: document.referrer,
        },
        user: {
          id: this.getUserId(),
          isAnonymous: true,
          source: this.getTrafficSource(),
        },
        device: {
          type: this.getDeviceType(),
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight,
          },
        },
        session: {
          cloakMode: this.getCloakMode(),
          featureFlags: this.getFeatureFlags(),
        },
      },
    }
    
    // Merge with specific event properties
    return { ...baseEvent, properties: { ...baseEvent.properties, ...properties } }
  }
  
  private sendImmediate(event: AnalyticsEvent) {
    this.adapters.forEach((adapter, platform) => {
      try {
        adapter.send(event)
      } catch (error) {
        console.error(`Failed to send event to ${platform}:`, error)
      }
    })
  }
  
  private sendBatch(events: AnalyticsEvent[]) {
    this.adapters.forEach((adapter, platform) => {
      try {
        if (adapter.supportsBatching) {
          adapter.sendBatch(events)
        } else {
          events.forEach(event => adapter.send(event))
        }
      } catch (error) {
        console.error(`Failed to send batch to ${platform}:`, error)
      }
    })
  }
}
```

### Platform Adapters
Example adapter pattern:
```typescript
// src/lib/analytics/events/adapters/base.ts
export abstract class AnalyticsAdapter {
  abstract name: string
  abstract supportsBatching: boolean
  
  abstract send(event: AnalyticsEvent): void
  
  sendBatch(events: AnalyticsEvent[]): void {
    // Default implementation for platforms that don't support batching
    events.forEach(event => this.send(event))
  }
  
  protected transformEventName(eventName: string): string {
    // Override in platform-specific adapters
    return eventName
  }
}

// src/lib/analytics/events/adapters/gtm.ts
export class GTMAdapter extends AnalyticsAdapter {
  name = 'gtm'
  supportsBatching = false
  
  send(event: AnalyticsEvent): void {
    if (typeof window === 'undefined' || !window.dataLayer) return
    
    // Transform to GTM format
    const gtmEvent = {
      event: event.eventName,
      event_category: this.getCategory(event.eventName),
      event_action: this.getAction(event.eventName),
      event_label: this.getLabel(event),
      ...this.flattenProperties(event.properties),
      trace_id: event.traceId,
      cloak_mode: event.context.session.cloakMode,
    }
    
    window.dataLayer.push(gtmEvent)
  }
  
  private getCategory(eventName: string): string {
    const parts = eventName.split('_')
    return parts[0] || 'general'
  }
  
  private getAction(eventName: string): string {
    const parts = eventName.split('_')
    return parts.slice(1).join('_') || eventName
  }
}
```

### Event Validation and Debug Mode
Based on [Source: architecture/development-standards.md]:
```typescript
// src/lib/analytics/events/validation.ts
import { ZodSchema } from 'zod'
import { EVENT_SCHEMAS } from './schemas'

export class EventValidator {
  private schemas: Map<string, ZodSchema> = new Map()
  private debugMode: boolean
  
  constructor(debugMode: boolean = false) {
    this.debugMode = debugMode
    this.registerSchemas()
  }
  
  validate(event: any): { valid: boolean; errors?: any[] } {
    const schema = this.schemas.get(event.eventName)
    
    if (!schema) {
      const error = `No schema found for event: ${event.eventName}`
      if (this.debugMode) {
        console.error('[Analytics Validation]', error)
      }
      return { valid: false, errors: [error] }
    }
    
    const result = schema.safeParse(event)
    
    if (!result.success && this.debugMode) {
      console.error('[Analytics Validation] Event failed validation:', {
        event: event.eventName,
        errors: result.error.errors,
        data: event,
      })
    }
    
    return {
      valid: result.success,
      errors: result.success ? undefined : result.error.errors,
    }
  }
  
  private registerSchemas() {
    // Register all event schemas
    Object.entries(EVENT_SCHEMAS).forEach(([name, schema]) => {
      this.schemas.set(name, schema)
    })
  }
}

// Debug mode utilities
export function enableAnalyticsDebug() {
  if (typeof window === 'undefined') return
  
  window.__ANALYTICS_DEBUG__ = true
  
  // Intercept all analytics calls
  const originalPush = window.dataLayer?.push
  if (originalPush) {
    window.dataLayer.push = function(...args: any[]) {
      console.log('[Analytics Debug] dataLayer.push:', args)
      return originalPush.apply(window.dataLayer, args)
    }
  }
  
  // Log all PostHog calls
  if (window.posthog) {
    const originalCapture = window.posthog.capture
    window.posthog.capture = function(...args: any[]) {
      console.log('[Analytics Debug] posthog.capture:', args)
      return originalCapture.apply(window.posthog, args)
    }
  }
}
```

### Event Monitoring Dashboard
```typescript
// src/components/analytics/EventMonitorDashboard.tsx
'use client'

import { useState, useEffect } from 'react'
import { EventManager } from '@/lib/analytics/events/event-manager'

interface EventLog {
  id: string
  timestamp: string
  eventName: string
  platform: string
  status: 'success' | 'error' | 'pending'
  data: any
}

export function EventMonitorDashboard() {
  const [events, setEvents] = useState<EventLog[]>([])
  const [filter, setFilter] = useState<string>('')
  const [isPaused, setIsPaused] = useState(false)
  
  useEffect(() => {
    if (isPaused) return
    
    // Subscribe to event stream
    const unsubscribe = EventManager.getInstance().subscribe((event) => {
      setEvents(prev => [{
        id: crypto.randomUUID(),
        timestamp: new Date().toISOString(),
        eventName: event.eventName,
        platform: 'all',
        status: 'success',
        data: event,
      }, ...prev].slice(0, 100)) // Keep last 100 events
    })
    
    return unsubscribe
  }, [isPaused])
  
  const filteredEvents = events.filter(event => 
    !filter || event.eventName.includes(filter)
  )
  
  return (
    <div className="event-monitor">
      <div className="controls">
        <input
          type="text"
          placeholder="Filter events..."
          value={filter}
          onChange={(e) => setFilter(e.target.value)}
        />
        <button onClick={() => setIsPaused(!isPaused)}>
          {isPaused ? 'Resume' : 'Pause'}
        </button>
        <button onClick={() => setEvents([])}>Clear</button>
      </div>
      
      <div className="event-list">
        {filteredEvents.map(event => (
          <EventLogItem key={event.id} event={event} />
        ))}
      </div>
    </div>
  )
}
```

### Event Batching System
Based on performance requirements:
```typescript
// src/lib/analytics/events/queue.ts
export class EventQueue {
  private queue: AnalyticsEvent[] = []
  private timer: NodeJS.Timeout | null = null
  private config: QueueConfig
  
  constructor(config: QueueConfig) {
    this.config = {
      maxSize: 100,
      flushInterval: 5000,
      maxRetries: 3,
      ...config,
    }
  }
  
  add(event: AnalyticsEvent) {
    this.queue.push(event)
    
    if (this.queue.length >= this.config.maxSize) {
      this.flush()
    } else if (!this.timer) {
      this.startTimer()
    }
  }
  
  private startTimer() {
    this.timer = setTimeout(() => {
      this.flush()
    }, this.config.flushInterval)
  }
  
  flush() {
    if (this.timer) {
      clearTimeout(this.timer)
      this.timer = null
    }
    
    if (this.queue.length === 0) return
    
    const events = [...this.queue]
    this.queue = []
    
    // Use requestIdleCallback for non-critical events
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() => {
        this.config.onFlush(events)
      }, { timeout: 1000 })
    } else {
      setTimeout(() => {
        this.config.onFlush(events)
      }, 0)
    }
  }
  
  // For critical events that need immediate sending
  sendImmediate(event: AnalyticsEvent) {
    this.config.onFlush([event])
  }
}
```

### Testing Utilities
Based on [Source: architecture/testing-strategy.md]:
```typescript
// src/lib/analytics/events/__tests__/test-utils.ts
import { vi } from 'vitest'
import { EventManager } from '../event-manager'

export function createMockEventManager() {
  const mockTrack = vi.fn()
  const mockSubscribe = vi.fn()
  
  return {
    track: mockTrack,
    subscribe: mockSubscribe,
    flush: vi.fn(),
    enableDebug: vi.fn(),
    reset: () => {
      mockTrack.mockClear()
      mockSubscribe.mockClear()
    },
  }
}

export function expectEventToMatch(event: any, expected: Partial<any>) {
  expect(event).toMatchObject({
    eventName: expected.eventName,
    properties: expected.properties,
    context: expect.objectContaining({
      session: expect.objectContaining({
        traceId: expect.any(String),
      }),
    }),
  })
}

// Generate test events
export function generateTestEvent(overrides?: Partial<AnalyticsEvent>): AnalyticsEvent {
  return {
    eventName: 'test_event',
    timestamp: new Date().toISOString(),
    traceId: 'test-trace-id',
    sessionId: 'test-session-id',
    properties: {},
    context: {
      page: {
        path: '/test',
        title: 'Test Page',
      },
      user: {
        id: 'test-user',
        isAnonymous: true,
        source: 'direct',
      },
      device: {
        type: 'desktop',
        viewport: { width: 1920, height: 1080 },
      },
      session: {
        cloakMode: 'white',
      },
    },
    ...overrides,
  }
}
```

### Migration Guide
Example migration from old to new system:
```typescript
// Before (scattered across different files):
posthog?.capture('promocode_interaction', { code, action })
window.dataLayer?.push({ event: 'promocode_interaction', code, action })
yandexMetrica.reachGoal('PROMOCODE_CLICKED')

// After (unified):
import { analytics } from '@/lib/analytics'

analytics.track('promocode_clicked', {
  code: 'SAVE20',
  merchant: 'Example Store',
  discount: '20% off',
  position: 'article-top',
  widgetType: 'inline',
})
```

### Environment Variables
No new environment variables needed - uses existing from stories 4.1-4.5

### File Locations
Based on [Source: architecture/source-tree.md]:
```
src/
├── lib/
│   └── analytics/
│       ├── events/
│       │   ├── index.ts
│       │   ├── event-manager.ts
│       │   ├── naming.ts
│       │   ├── schemas.ts
│       │   ├── validation.ts
│       │   ├── queue.ts
│       │   ├── adapters/
│       │   │   ├── base.ts
│       │   │   ├── gtm.ts
│       │   │   ├── ga4.ts
│       │   │   ├── yandex.ts
│       │   │   └── posthog.ts
│       │   └── __tests__/
│       └── index.ts (updated unified export)
└── components/
    └── analytics/
        └── EventMonitorDashboard.tsx
```

### Testing
#### Test File Locations
- Event Manager: `src/lib/analytics/events/__tests__/event-manager.test.ts`
- Adapters: `src/lib/analytics/events/adapters/__tests__/*.test.ts`
- Validation: `src/lib/analytics/events/__tests__/validation.test.ts`
- E2E tests: `e2e/unified-analytics.spec.ts`

#### Testing Standards
Based on [Source: architecture/testing-strategy.md]:
- Mock all external analytics libraries
- Test event transformation for each platform
- Verify batching and queuing behavior
- Test validation catches malformed events
- E2E test complete event flow across platforms

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-07 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_