# Story 4.4: PostHog Product Analytics

## Status
Draft

## Story
**As a** product manager,
**I want** detailed interaction analytics,
**so that** we can optimize the user experience.

## Acceptance Criteria
1. Initialize PostHog with project API key
2. Identify users with persistent anonymous IDs
3. Track feature flags for A/B testing widgets
4. Implement funnel tracking from land to conversion
5. Set up cohort analysis for user segments
6. Track custom events for all widget interactions
7. Configure session recording (white mode only)
8. Implement feature flag SDK for experimentation

## Tasks / Subtasks
- [ ] Enhance PostHog initialization (AC: 1)
  - [ ] Update src/lib/analytics/posthog.ts configuration
  - [ ] Add persistence configuration for user IDs
  - [ ] Configure session replay settings
  - [ ] Enable feature flag polling
  - [ ] Set up privacy-preserving defaults
  - [ ] Test initialization in different environments
- [ ] Implement user identification system (AC: 2)
  - [ ] Create anonymous ID generation utility
  - [ ] Store ID in localStorage with fallback to cookies
  - [ ] Implement ID persistence across sessions
  - [ ] Handle ID migration on user actions
  - [ ] Add user properties (cloak mode, source)
  - [ ] Test ID persistence across domains
- [ ] Set up feature flag system (AC: 3)
  - [ ] Configure PostHog feature flags
  - [ ] Create feature flag React hook
  - [ ] Implement widget variant testing
  - [ ] Add flag evaluation caching
  - [ ] Create fallback mechanism
  - [ ] Test flag rollout behavior
- [ ] Implement conversion funnel tracking (AC: 4)
  - [ ] Define funnel stages (land → view → interact → convert)
  - [ ] Create funnel event tracking
  - [ ] Add funnel stage properties
  - [ ] Implement drop-off tracking
  - [ ] Configure funnel visualization
  - [ ] Test complete funnel flow
- [ ] Configure user segmentation (AC: 5)
  - [ ] Define cohort properties (traffic source, behavior)
  - [ ] Implement cohort assignment logic
  - [ ] Track cohort-specific events
  - [ ] Create behavioral cohorts
  - [ ] Set up cohort comparison
  - [ ] Test cohort analytics
- [ ] Enhance widget interaction tracking (AC: 6)
  - [ ] Update promocode widget events
  - [ ] Add detailed interaction properties
  - [ ] Track widget visibility and engagement
  - [ ] Implement scroll depth for widgets
  - [ ] Add timing metrics
  - [ ] Test all interaction types
- [ ] Configure session recording controls (AC: 7)
  - [ ] Implement recording based on cloak mode
  - [ ] Disable recording for black mode users
  - [ ] Add privacy masking rules
  - [ ] Configure recording quality settings
  - [ ] Implement consent controls
  - [ ] Test recording privacy
- [ ] Implement feature flag SDK (AC: 8)
  - [ ] Create typed feature flag interface
  - [ ] Build React components for experiments
  - [ ] Add server-side flag evaluation
  - [ ] Implement flag override system
  - [ ] Create A/B test utilities
  - [ ] Test experiment variations
- [ ] Integrate with existing analytics (AC: 1-8)
  - [ ] Update unified analytics wrapper
  - [ ] Ensure GTM dataLayer compatibility
  - [ ] Maintain event consistency with GA4/Yandex
  - [ ] Add PostHog to debug dashboard
  - [ ] Test parallel event tracking
  - [ ] Document PostHog-specific features
- [ ] Write comprehensive tests (AC: 1-8)
  - [ ] Unit test PostHog utilities
  - [ ] Test user identification logic
  - [ ] Mock feature flag responses
  - [ ] Test funnel event sequences
  - [ ] Test session recording controls
  - [ ] E2E test complete analytics flow

## Dev Notes
### Previous Story Insights
- Story 4.1 established GTM as central analytics hub
- Story 4.2 implemented GA4 with conversion tracking
- Story 4.3 added Yandex Metrica with session recording controls
- PostHog is already partially integrated per architecture docs
- Existing events: pageView, cloakDecision, promocodeInteraction, conversionEvent
- Trace ID system established for event correlation

### Enhanced PostHog Configuration
Based on [Source: architecture/observability-strategy.md#posthog-analytics-integration]:
```typescript
// src/lib/analytics/posthog.ts
import posthog from 'posthog-js'
import { PostHogConfig } from 'posthog-js'

// Extended configuration for full feature set
const posthogConfig: Partial<PostHogConfig> = {
  api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST,
  capture_pageview: false, // Manual control
  capture_pageleave: true,
  persistence: 'localStorage+cookie', // Fallback strategy
  autocapture: false, // Manual control for privacy
  disable_session_recording: false, // Will control dynamically
  session_recording: {
    maskAllInputs: true,
    maskTextSelector: '[data-sensitive]',
    blockClass: 'ph-no-record',
    blockSelector: '.promocode-code', // Don't record actual codes
    slimDOMOptions: {
      script: false,
      comment: false,
      headFavicon: false,
      headWhitespace: false,
      headMetaDescKeywords: false,
      headMetaSocial: false,
      headMetaRobots: false,
      headMetaHttpEquiv: false,
      headMetaAuthorship: false,
      headMetaVerification: false,
    },
  },
  // Feature flags configuration
  bootstrap: {
    featureFlags: {
      // Default flags for immediate availability
      'widget-variant-test': false,
      'enhanced-analytics': true,
    },
  },
  loaded: (posthog) => {
    // Set up after initialization
    const traceId = window.__TRACE_ID__
    if (traceId) {
      posthog.register({
        trace_id: traceId,
        initial_cloak_mode: document.body.classList.contains('is-black-mode') ? 'black' : 'white',
      })
    }
  },
}

export function initPostHog() {
  if (typeof window !== 'undefined' && process.env.NEXT_PUBLIC_POSTHOG_KEY) {
    posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY, posthogConfig)
    
    // Control session recording based on cloak mode
    updateSessionRecording()
  }
}

export function updateSessionRecording() {
  const isBlackMode = document.body.classList.contains('is-black-mode')
  
  if (isBlackMode) {
    posthog?.stopSessionRecording()
  } else {
    posthog?.startSessionRecording()
  }
}
```

### User Identification System
Based on [Source: architecture/observability-strategy.md]:
```typescript
// src/lib/analytics/user-identification.ts
import { v4 as uuidv4 } from 'uuid'
import posthog from 'posthog-js'

const ANON_ID_KEY = 'ph_anonymous_id'
const ID_EXPIRY_DAYS = 365

export class UserIdentification {
  private static instance: UserIdentification
  
  static getInstance(): UserIdentification {
    if (!UserIdentification.instance) {
      UserIdentification.instance = new UserIdentification()
    }
    return UserIdentification.instance
  }

  getOrCreateAnonymousId(): string {
    // Try localStorage first
    let anonId = localStorage.getItem(ANON_ID_KEY)
    
    if (!anonId) {
      // Fallback to cookie
      anonId = this.getCookie(ANON_ID_KEY)
      
      if (!anonId) {
        // Generate new ID
        anonId = `anon_${uuidv4()}`
      }
      
      // Store in both localStorage and cookie
      this.persistId(anonId)
    }
    
    return anonId
  }

  identifyUser(properties?: Record<string, any>) {
    const anonId = this.getOrCreateAnonymousId()
    
    posthog?.identify(anonId, {
      ...properties,
      first_seen: new Date().toISOString(),
      source: this.getTrafficSource(),
      cloak_eligible: this.isCloakEligible(),
    })
  }

  private persistId(id: string) {
    // Store in localStorage
    localStorage.setItem(ANON_ID_KEY, id)
    
    // Also set cookie as fallback
    const expires = new Date()
    expires.setDate(expires.getDate() + ID_EXPIRY_DAYS)
    
    document.cookie = `${ANON_ID_KEY}=${id}; expires=${expires.toUTCString()}; path=/; SameSite=Strict; Secure`
  }

  private getCookie(name: string): string | null {
    const match = document.cookie.match(new RegExp(`(^| )${name}=([^;]+)`))
    return match ? match[2] : null
  }

  private getTrafficSource(): string {
    const params = new URLSearchParams(window.location.search)
    if (params.get('gclid')) return 'google'
    if (params.get('yclid')) return 'yandex'
    if (params.get('fbclid')) return 'facebook'
    if (document.referrer.includes('google.')) return 'google_organic'
    if (document.referrer.includes('yandex.')) return 'yandex_organic'
    return 'direct'
  }

  private isCloakEligible(): boolean {
    const params = new URLSearchParams(window.location.search)
    return !!(params.get('yclid') || params.get('gclid'))
  }
}
```

### Feature Flag System
Based on A/B testing requirements:
```typescript
// src/lib/analytics/feature-flags.ts
import { useEffect, useState } from 'react'
import posthog from 'posthog-js'

// Type-safe feature flags
export type FeatureFlags = {
  'widget-variant-test': 'control' | 'variant-a' | 'variant-b'
  'enhanced-analytics': boolean
  'new-promocode-modal': boolean
  'scroll-triggered-widget': boolean
  'mobile-sticky-cta': boolean
}

export function useFeatureFlag<K extends keyof FeatureFlags>(
  flagKey: K,
  fallback: FeatureFlags[K]
): FeatureFlags[K] {
  const [flagValue, setFlagValue] = useState<FeatureFlags[K]>(fallback)
  
  useEffect(() => {
    // Get initial value
    const value = posthog?.getFeatureFlag(flagKey) as FeatureFlags[K]
    if (value !== undefined) {
      setFlagValue(value)
    }
    
    // Listen for updates
    posthog?.onFeatureFlags(() => {
      const newValue = posthog.getFeatureFlag(flagKey) as FeatureFlags[K]
      if (newValue !== undefined) {
        setFlagValue(newValue)
      }
    })
  }, [flagKey])
  
  return flagValue
}

// Server-side flag evaluation
export async function getServerFeatureFlag<K extends keyof FeatureFlags>(
  flagKey: K,
  distinctId: string,
  fallback: FeatureFlags[K]
): Promise<FeatureFlags[K]> {
  try {
    const response = await fetch(`${process.env.POSTHOG_HOST}/decide`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        api_key: process.env.POSTHOG_PROJECT_API_KEY,
        distinct_id: distinctId,
        groups: {},
        person_properties: {},
        group_properties: {},
      }),
    })
    
    const data = await response.json()
    return data.featureFlags?.[flagKey] ?? fallback
  } catch {
    return fallback
  }
}
```

### Funnel Tracking Implementation
Based on conversion optimization needs:
```typescript
// src/lib/analytics/funnel-tracking.ts
export const funnelStages = {
  LANDED: 'funnel_landed',
  ARTICLE_VIEWED: 'funnel_article_viewed', 
  PROMOCODE_VIEWED: 'funnel_promocode_viewed',
  PROMOCODE_INTERACTED: 'funnel_promocode_interacted',
  CONVERTED: 'funnel_converted',
} as const

export type FunnelStage = typeof funnelStages[keyof typeof funnelStages]

export class FunnelTracker {
  private sessionStages: Set<FunnelStage> = new Set()
  private startTime: number = Date.now()
  
  trackStage(stage: FunnelStage, properties?: Record<string, any>) {
    // Only track each stage once per session
    if (this.sessionStages.has(stage)) return
    
    this.sessionStages.add(stage)
    
    const stageNumber = Object.values(funnelStages).indexOf(stage) + 1
    const previousStages = Array.from(this.sessionStages)
    const timeInFunnel = Date.now() - this.startTime
    
    posthog?.capture(stage, {
      ...properties,
      funnel_stage_number: stageNumber,
      funnel_previous_stages: previousStages,
      funnel_time_elapsed_ms: timeInFunnel,
      funnel_session_id: window.__TRACE_ID__,
    })
    
    // Track drop-off if user leaves
    if (stage === funnelStages.PROMOCODE_VIEWED) {
      this.setupDropOffTracking()
    }
  }
  
  private setupDropOffTracking() {
    // Track if user leaves without converting
    window.addEventListener('beforeunload', () => {
      if (!this.sessionStages.has(funnelStages.CONVERTED)) {
        posthog?.capture('funnel_drop_off', {
          last_stage: Array.from(this.sessionStages).pop(),
          stages_completed: this.sessionStages.size,
          time_in_funnel_ms: Date.now() - this.startTime,
        })
      }
    })
  }
}
```

### Enhanced Widget Tracking
Based on [Source: architecture/observability-strategy.md#posthog-analytics-integration]:
```typescript
// src/lib/analytics/widget-analytics.ts
import { analytics } from './posthog'

export const widgetAnalytics = {
  // Enhanced tracking beyond basic interactions
  trackWidgetView: (widget: {
    type: string
    position: string
    variant?: string
    code: string
  }) => {
    // Use Intersection Observer for viewability
    const element = document.querySelector(`[data-promocode="${widget.code}"]`)
    if (!element) return
    
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
            posthog?.capture('widget_viewed', {
              ...widget,
              viewport_percentage: Math.round(entry.intersectionRatio * 100),
              time_to_view_ms: Date.now() - window.performance.timing.domContentLoadedEventEnd,
            })
            
            observer.disconnect()
          }
        })
      },
      { threshold: [0.5] }
    )
    
    observer.observe(element)
  },

  trackWidgetEngagement: (widget: {
    code: string
    action: 'hover' | 'focus' | 'copy_attempt' | 'copy_success'
    duration_ms?: number
  }) => {
    posthog?.capture('widget_engagement', {
      ...widget,
      trace_id: window.__TRACE_ID__,
      timestamp: new Date().toISOString(),
    })
  },

  trackWidgetScroll: (widget: {
    code: string
    scroll_depth: number
  }) => {
    posthog?.capture('widget_scroll_interaction', widget)
  },
}
```

### Session Recording Controls
Based on privacy requirements:
```typescript
// src/lib/analytics/session-recording.ts
export class SessionRecordingController {
  private observer: MutationObserver | null = null
  
  initialize() {
    // Initial state based on cloak mode
    this.updateRecordingState()
    
    // Watch for cloak mode changes
    this.observer = new MutationObserver(() => {
      this.updateRecordingState()
    })
    
    this.observer.observe(document.body, {
      attributes: true,
      attributeFilter: ['class'],
    })
    
    // Also respect user consent
    this.setupConsentHandling()
  }
  
  private updateRecordingState() {
    const isBlackMode = document.body.classList.contains('is-black-mode')
    const hasConsent = this.checkRecordingConsent()
    
    if (isBlackMode || !hasConsent) {
      posthog?.stopSessionRecording()
      console.log('[PostHog] Session recording disabled')
    } else {
      posthog?.startSessionRecording()
      console.log('[PostHog] Session recording enabled')
    }
  }
  
  private checkRecordingConsent(): boolean {
    // Check for consent cookie or localStorage
    return localStorage.getItem('analytics_consent') === 'granted'
  }
  
  private setupConsentHandling() {
    // Listen for consent changes
    window.addEventListener('consent-updated', (event: CustomEvent) => {
      if (event.detail.analytics === 'granted') {
        this.updateRecordingState()
      }
    })
  }
  
  addSensitiveSelector(selector: string) {
    // Dynamically add elements to mask
    const elements = document.querySelectorAll(selector)
    elements.forEach(el => {
      el.classList.add('ph-no-record')
    })
  }
}
```

### Environment Variables
Based on [Source: architecture/environment-configuration.md]:
```env
# PostHog
NEXT_PUBLIC_POSTHOG_KEY=phc_xxxxxxxxxxxxxxxxxxxxxxxxxxx
NEXT_PUBLIC_POSTHOG_HOST=https://app.posthog.com
POSTHOG_PROJECT_API_KEY=phx_xxxxxxxxxxxxxxxxxxxxxxxxxxx
```

### Integration with Unified Analytics
Update existing wrapper from [Source: architecture/observability-strategy.md]:
```typescript
// src/lib/analytics/index.ts
import { posthog } from './posthog'
import { ga4Events } from './ga4-events'
import { yandexMetricaEvents } from './yandex-metrica'
import { FunnelTracker, funnelStages } from './funnel-tracking'
import { widgetAnalytics } from './widget-analytics'

const funnelTracker = new FunnelTracker()

export const analytics = {
  // Enhanced promocode interaction tracking
  promocodeInteraction: (data: PromocodeInteractionData) => {
    // Track in all analytics platforms
    posthog?.capture('promocode_interaction', data)
    ga4Events.promocodeInteraction(data)
    yandexMetricaEvents.promocodeInteraction(data)
    
    // Additional PostHog-specific tracking
    if (data.action === 'viewed') {
      funnelTracker.trackStage(funnelStages.PROMOCODE_VIEWED, data)
      widgetAnalytics.trackWidgetView({
        type: 'promocode',
        position: data.position,
        code: data.code,
        variant: data.variant,
      })
    } else if (data.action === 'clicked') {
      funnelTracker.trackStage(funnelStages.PROMOCODE_INTERACTED, data)
    }
  },
  
  // Feature flag exposure tracking
  trackFeatureFlagExposure: (flag: string, variant: string) => {
    posthog?.capture('$feature_flag_called', {
      $feature_flag: flag,
      $feature_flag_response: variant,
    })
  },
}
```

### File Locations
Based on [Source: architecture/source-tree.md]:
```
src/
├── lib/
│   └── analytics/
│       ├── posthog.ts (enhanced)
│       ├── user-identification.ts
│       ├── feature-flags.ts
│       ├── funnel-tracking.ts
│       ├── widget-analytics.ts
│       └── session-recording.ts
```

### Testing
#### Test File Locations
- PostHog config: `src/lib/analytics/__tests__/posthog.test.ts`
- User identification: `src/lib/analytics/__tests__/user-identification.test.ts`
- Feature flags: `src/lib/analytics/__tests__/feature-flags.test.ts`
- E2E tests: `e2e/posthog-analytics.spec.ts`

#### Testing Standards
Based on [Source: architecture/testing-strategy.md]:
- Mock posthog-js module
- Test user ID persistence across sessions
- Test feature flag variations
- Verify session recording controls
- Test funnel stage progression
- E2E test complete user journey with analytics

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-07 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_