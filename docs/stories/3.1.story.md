# Story 3.1: Data-Action Widget Framework

## Status
Draft

## Story
**As a** developer,
**I want** a flexible system for defining interactive widgets in HTML,
**so that** content editors can place promotional elements anywhere.

## Acceptance Criteria
1. Create widget hydration system that finds all [data-action] elements
2. Implement widget registry for mapping action types to React components
3. Support data-param-* attributes for widget configuration
4. Only hydrate widgets when .is-black-mode class is present
5. Ensure widgets render as static HTML for white mode users
6. Create TypeScript interfaces for widget props and configuration
7. Implement error boundaries around each widget
8. Test hydration with multiple widgets on same page

## Tasks / Subtasks
- [ ] Create widget registry system (AC: 2, 6)
  - [ ] Create src/lib/widgets/registry.ts
  - [ ] Define WidgetRegistry class with register/get methods
  - [ ] Create TypeScript interfaces for widget configuration
  - [ ] Implement type-safe widget registration pattern
  - [ ] Add validation for widget type strings
  - [ ] Create widget factory function
- [ ] Implement widget hydration scanner (AC: 1, 4)
  - [ ] Create src/components/article/ActionHydrator.tsx
  - [ ] Scan for elements with [data-action] attribute
  - [ ] Parse data-param-* attributes into configuration object
  - [ ] Check for .is-black-mode class before hydration
  - [ ] Create progressive hydration queue
  - [ ] Implement IntersectionObserver for lazy hydration
- [ ] Create base widget component structure (AC: 6, 7)
  - [ ] Create src/components/widgets/BaseWidget.tsx
  - [ ] Define WidgetProps interface extending HTMLAttributes
  - [ ] Implement error boundary wrapper component
  - [ ] Add widget loading state component
  - [ ] Create widget error fallback UI
  - [ ] Set up proper displayName for debugging
- [ ] Build widget configuration parser (AC: 3, 6)
  - [ ] Create src/lib/widgets/config-parser.ts
  - [ ] Parse data-param-* attributes into typed config
  - [ ] Create Zod schemas for widget configurations
  - [ ] Implement discriminated union for widget types
  - [ ] Add runtime validation with error handling
  - [ ] Create ValidationError class for detailed errors
- [ ] Implement white mode static rendering (AC: 5)
  - [ ] Create server-side widget renderer
  - [ ] Ensure widgets output valid static HTML
  - [ ] Add data attributes for client hydration
  - [ ] Implement no-JS fallback behavior
  - [ ] Test SEO compatibility of static output
- [ ] Set up widget mounting system (AC: 1, 7)
  - [ ] Create React root for each widget instance
  - [ ] Implement proper cleanup on unmount
  - [ ] Add error boundary around each mount point
  - [ ] Handle widget communication via context
  - [ ] Ensure isolated widget state management
- [ ] Create example widget implementations (AC: 2, 8)
  - [ ] Create placeholder PromoCodeWidget stub
  - [ ] Create placeholder CountdownWidget stub
  - [ ] Register widgets in the registry
  - [ ] Add widget demo in ArticleContent
  - [ ] Test multiple widget types on same page
- [ ] Write comprehensive tests (AC: 8)
  - [ ] Unit test widget registry functionality
  - [ ] Test configuration parser with various inputs
  - [ ] Test hydration with mock DOM elements
  - [ ] Test error boundary behavior
  - [ ] Test white mode vs black mode rendering
  - [ ] E2E test widget hydration on page load

## Dev Notes
### Previous Story Insights
- Stories 2.1-2.6 established the cloaking infrastructure with .is-black-mode class
- Widget system must integrate with existing cloak detection
- Hydration should only occur for verified black mode users

### Widget Registry Pattern
Based on [Source: architecture/component-standards.md]:
```typescript
// Use discriminated unions for type safety
export interface BaseWidgetProps extends HTMLAttributes<HTMLDivElement> {
  type: string;
  config: unknown;
}

// Implement forwardRef for DOM access
export const BaseWidget = forwardRef<HTMLDivElement, BaseWidgetProps>((props, ref) => {
  // Widget implementation
});
BaseWidget.displayName = 'BaseWidget';
```

### Type Safety Requirements
Based on [Source: architecture/type-safety-validation.md]:
```typescript
// Widget configuration schemas
const WidgetConfigSchema = z.discriminatedUnion('type', [
  z.object({
    type: z.literal('promocode'),
    code: z.string().regex(/^[A-Z0-9]{4,20}$/),
    discount: z.string(),
    description: z.string().optional(),
  }),
  // Add more widget types
]);

// ValidationError for detailed error reporting
export class ValidationError extends Error {
  constructor(
    message: string,
    public errors: z.ZodError,
    public rawData: unknown
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}
```

### React 19 Features
Based on [Source: architecture/react-19-features.md]:
- Use `useOptimistic` for instant widget feedback
- Implement `useTransition` for non-blocking interactions
- Consider `use` hook for async widget data
- Wrap widgets in Suspense boundaries

### Project Structure
Based on [Source: architecture/source-tree.md]:
```
src/
├── components/
│   ├── article/
│   │   ├── ArticleContent.tsx      # Main article renderer
│   │   └── ActionHydrator.tsx      # Hydrates [data-action] elements
│   └── widgets/
│       ├── BaseWidget.tsx          # Base widget component
│       └── index.ts                # Widget exports
├── lib/
│   └── widgets/
│       ├── registry.ts             # Widget registry system
│       └── config-parser.ts        # Configuration parser
```

### Error Boundary Implementation
Based on [Source: architecture/component-standards.md]:
```typescript
// Each widget wrapped in error boundary
<ErrorBoundary fallback={<WidgetErrorFallback />}>
  <Widget {...props} />
</ErrorBoundary>
```

### Testing Approach
Based on [Source: architecture/testing-strategy.md]:
- Use MSW for mocking widget API calls
- Custom render utilities with providers
- Test data-action parsing edge cases
- Validate Zod schema error handling
- E2E tests with Playwright for hydration

### Performance Considerations
- Progressive hydration with IntersectionObserver
- React.memo for widget components
- Suspense boundaries for async data
- Cache widget instances
- Use 'use client' directive appropriately

### File Locations
Based on [Source: architecture/source-tree.md]:
```
src/
├── lib/
│   └── widgets/
│       ├── registry.ts
│       └── config-parser.ts
├── components/
│   ├── article/
│   │   └── ActionHydrator.tsx
│   └── widgets/
│       └── BaseWidget.tsx
```

### Testing
#### Test File Locations
Based on [Source: architecture/testing-strategy.md]:
- Unit tests: `src/lib/widgets/__tests__/`
- Component tests: `src/components/widgets/__tests__/`
- E2E tests: `e2e/widgets.spec.ts`

#### Testing Standards
- Use React Testing Library for component tests
- Mock widget registry for isolated testing
- Test error boundaries with invalid configs
- Verify hydration only occurs with .is-black-mode
- Test progressive hydration behavior

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-07 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record
### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_